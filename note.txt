Quando inserisco la posizione mi servira':
- la foto;
- la posizione: questa potra' essere data da: 1. coordinate GPS, 2. un indirizzo da validare tramite un api (?)


Sulla mappa poi mostrero' 1 indicatore per punto di inquinamento raggruppandoli in funzione della distanza tra di essi e del livello di ingrandimento della mappa.
Se un indicatore e' individuale clicandolo si potra' raggiungere direttamente una pagina con la foto dell'inquinamento e una descrizione (se prevista),
se si clicca su un indicatore multiplo invece si espandera' il popup ad una lista da cui si potra' selezionare il singolo punto che si vuole guardare.

? mettere autenticazione per poter modificare solo le proprie sottomissioni? magari un servizio di notifica per quando qualcuno pubblica un'altra
segnalazione vicina alla nostra?

Al momento devo capire come differenziare un click per selezionare da un click sulla mappa.
Voglio anche aggiungere un bottone per chiudere popup al popup stesso.
click sulla mappa dovrebbe avere al suo interno: coordinate, x per chiudere, link per segnalare in quelle coordinate.
(il click sulla mappa deve anche creare una feature?)

let x-direction = right;
let y-direction = bottom;
let xoffset = ? get element width
let yoffset = ? get element height
let coordinates = e.coordinate;
let [clickX, clickY] = getclickedpixelfromcoordinate
let spaceBottom, spaceTop = ? 
let spaceRight, spaceLeft = ?
if spaceRight < xoffset && spaceLeft >= xoffset: x-direction = left;
if spaceBottom < yoffset && spaceTop >= yoffset: y-direction = top;
if x-direction !== right:
    x-position = clickX - xoffset;
if y-direction !== bottom:
    y-position = clickY - yoffset;
newCoordinates = getCoordinatesFromPixel(x-position, y-position)
setPosition(newCoordinates);

getPixelFromCoordinate(coordinate) // to translate coordinate into pixel
getCoordinateFromPixel(pixel)
getEventPixel(event)
getSize() to get full map size?
getView() / getViewPort()?


useful link for reference https://stackoverflow.com/questions/34209971/popover-overlay-in-openlayers-3-does-not-extend-beyond-view

setup the comments extension

object destructuring is really good, if an object has some properties like prop1 and prop2 you can extract them with:
let {prop1, prop2} = object; if you want you can also give them an alias like let {prop1: myProp1, prop2: myProp2} = object; and then the variables will be myProp1/2

res.send sends the content as text/html, res.json sets it as json content type.

require first tries to find the absolute path of the file to be loaded. if you do `node` and then `module.paths` it prints a list of dicrectories in which its searching for node_modules.
it tries first with folder and files with maximum specificity (inside the project node_modules folder) and then it goes back to the outer folder and so on until it finds a match, prompting an error if it can't.
You can also specify another folder in which to start the search by using a relative or absolute path.
It searches for a js file matching what's searched but it also searches for a folder that matches the name with an index.js file inside of it. You can change the name of the main file within a module folder in package.json
require.resolve checks if a package is available without loading if it is. Can be used for optional modules that get used when they're there.
module.exports allows you to set a return value from the module that's being required. you can also specify multiple properties of the export object to be returned like
exports.a = ...; exports.b = ...; and then the returned value will be exports = {a: ..., b: ...};
You can't instead just substitude the export object wth something else like: `exports = {...}` because exports is just a reference to module.exports object, by assigning it another value we're losing that reference.
Node runs a wrapper function around your code not to give it global scope in the procoess it does something like 
function (require, module, __filename, __dirname) {
  let exports = module.exports;
  // Your Code...
  return module.exports;
}
Require also allows you to import json files and c++?
Node caches the module it loads so that if someone tries to load them twice it just returns the previous module.exports. If you want to run something twice just return a function that you can run as many times as you want.

Problems I encoutered: 
- various typos
- in my isLoggedIn function I was checking if user was not authenticated, if that was the case I would redirect and then I would call return next(). I thought the redirect would be enough to act like a guard like it did previously but for some reason it didnt anymore
  and ended up trying to send headers twice and crashing the app.
- I had forgotten to re-include bodyParser somewhere in my app so my auth routes were not getting the body parameters. Despite what I thought I had read last week it seems that express does not have its own body parser again.
  by default express does not populate req.body, you use express.json() or bodyParser.urlEncoded({extended:true}). .json / .urlEncoded decides which parser handles which type of data. Each one of these when called parses the data and creates the .body, 
  urlencoded is normal data that is like html escaped space becomes %20 etc. extended means that instead of just getting string values you can get full objects through this parsing (? more to be learned)
- huge waste of time: somehow in rewriting / updating my logged in function I was returning `next` instead of `next()`. Not hard to fix, if you don't get completely derailed. First I thought that the problem might be an asynchronous verify function since any 
  async function returns a promise value and I thought maybe the internal workings of passport.authenticate might not allow that. So I went back to callbacks for verifying user credentials. After that I was still encountering problems, I blamed it on a redirect
  not working correctly. This seemed to be caused by problems in either the redirect function itself or the url I was providing which was supposed to be a saved url of whichever log in protected resource the user was trying to access while not authenticated.
  I thought since I had a fallback static url redirect when the first value was undefined that if not with redirect the problem must be in the saved url being a truthy value but an invalid one. After using only a static value things started working again. So
  obviously since I hated the callback triangle thing I started retrying the async methods for db access etc. Those seemed to work, frustrated because I had spent a ton of time thinking the problem was with async without noticing a bad redirect I got back to work.
  Now I noticed that randomly /profile was no longer working either. And look around a bit this was access protected as well, and requests were not getting there even if I was authenticated. Shortly after this luckily I saw my mistake and was able to fix it. But yeah 
  wasted a ton of time putting in doubt a lot of code because of a small distraction.
- to escape identifiers you need to use a different function than the one for values, otherwise you get them wrapped in '' and sql is NOT happy about that.
- I tried making the inputs fields that substituted the real elements in the submission page have the same size as the originals. I tried giving them the same width and height with offsetWidth/... but sometimes that created problems with the length of the title which
  would flow on another line. I tried doing a +1 px (by the way, the first time I forgot the +'px' when setting style) but that made it so they were growing every time I swapped which was not ideal. Finally just using boundingClientRect seeemed to work. Only catch was
  that after the user would submit updates to the server the length of title etc would change but the size would be still locked. So I had to remove one final piece of logic to unset the width/height property after the user confirmed updates to a submission.
- while trying to add the option to modify the image I encountered quite a bit of slow downs. First I wasn't sure how I wnated the interface itself to look. I started by placing a button-looking-label in the middle of the image. Then I realized I wanted to have 
  text notifying the user that he had selected a new image for upload. I had to modify the modal specifically for the image field since it wouldn't have a meaningful old field and the updated data to send was not going to be a simple key, value pair.
  I then realized that I wanted a second button to undo the image upload if the user changed his mind, without having to discard all edits and restarting. So I changed what was only a paragraph absolutely positioned (actually that became a 'pre') into a div with a 
  paragraph and a button. Had to reposition the div. For some reason the row was becoming higher than the height of the image, some sort of undesired padding? Not sure yet. I just ended up forcing the image height on the div as well. Then I resized the undo button, 
  absolutely positioned that as well and added the logic to not only hide the update div but also remove the uploaded file. I realized that the uploaded file seemed to be persisting through page reloads (or so I remember) and therefore I just started resetting that
  field any time the page was loaded with editing enabled. Then I got to the point where I needed to actually send the image data and update it. I wasn't even sure if it was possible, or how hard it was going to be. At first I just tried setting a new field on the changes
  file with value = to the file and then sending it without the json.stringify. Node was complaining about the request object size though. So I tried changing the content type from json/app to multipart form, that didn't work either because apparently that relies on a 
  boundary element to separate each key,value pair. So I found out from stack overflow that I could just delete the content type data. After that node wasn't complaining any more. I slapped multer even on this point. Now I stupidly tried to access req.body.name, 
  thinking that was a value set from multer after generating the file name. Took longer than I would like to admit to realize that it was just the .name field in the form data normally, and that right now it was missing because not in every update I was changing the 
  submission name. Understood that we were ready to proceed with most of the rest of the stuff. A part from a couple of typos and problems with variable scope it was 'smooth sailing'. It doesn't look as clean as I would like to because I had to add some conditional logic
  based on whether I had to update the image file, which is more laborious than just updating a field in the db (need to create new imagename, save the image, delete the old one). To delete old image file I also have to do an additional database query which I don't love,
  unless somehow I can grab the old data before updating it? maybe it might worth taking a look at. Anyway now it seems done, and I also updated the delete route to delete the old image, which again meant another query to get the old name.







  when I click on the map:
  - if it's not the first click I do I have to clean up what was previously selected or the last click marker.
  - if the click is on a feature (that is not the click marker, which should be obvious if the first step works synchronously but I'm not sure if it will be) I highlight it and show a popup containing data about the feature
    if it's on the map I create a feature there with a popup saying where was the click and a link to submit
  - I save the selected marker, or the newly created one, to be able to undo it on next click;
  - if I haven't done it earlier I show the popup.

  expanding:
  if(lastInteraction !== null){
    if(lastInteraction.type === 'select' ){
      if(lastInteraction.marker is an array){
        lastInteraction.marker.forEach(marker => marker.remove or source.removeFeature(marker));
      } else {
        lastInteraction.marker.remove(); or source.removeFeature(lastInteraction.marker);
      }
    } else {
      lastInteraction.marker.setStyle(unselectedStyle);
    }
    // should I reset lastInteraction? in theory if the program is working correctly it should automatically be overwritten by another interaction. Also if I reset it I can't use it as condition to check if click landed on a real site or last clickmarker
  }
  let featuresClicked = getFeaturesAtPixel();
  if (featuresClicked.length === 0){ // clicked on clean map
    let marker = createMarker();
    lastInteraction.type = 'clickMarker';
    lastInteraction.marker = marker;
    source.addFeature(marker);
    createPopup(clean, coordinates); // somewhere here I might / will have to adjust the coordinates if I'm wrapping around or whatever; there's also the whole open popup to the right or left etc to be calculated.
    positionpopup();
  } else {
      lastInteraction.type = 'select'; // if there isn't the problem with clicking a click marker, otherwise have to make sure it's not that case;
    if (featuresClicked.length > 1){
      // I already have logic to handle this. I just realized though that in the select interaction I need to be able to differentiate between multiple markers selected in last iteration or just one. Can just check if it's an array I guess.
      lastInteraction.marker = []
      featuresClicked.forEach(feature => 
        feature.setStyle(selectedStyle);
        lastInteraction.marker.push(feature);   
      )
    } else { // only one feature selected
      featuresClicked[0].setStyle(selectedStyle);
      lastInteraction.marker = featuresClicked[0] //?
    }
    createPopup(featuresClicked, coordinates); // will need to get data about features by comparing them to the array we're using to create them. Either this or next function will need to adjust popup positioning to be on feature coords and possibly wrap around.
    positionPopup();
  }